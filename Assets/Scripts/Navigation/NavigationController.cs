using UnityEngine;
using UnityEngine.InputSystem;
using System.Collections.Generic;
using System.Collections;
using System.Linq;

public class DroneSpawner : MonoBehaviour
{
    [Header("TEKNOFEST 5.2 S√úR√ú HALƒ∞NDE NAVƒ∞GASYON PARAMETRELERƒ∞")]
    [Space(10)]
    [Tooltip("Z - U√ßu≈ü ƒ∞rtifasƒ± (metre)")]
    public float ucusIrtifasi = 15f;
    
    [Tooltip("T1 - Ara Nokta Ula≈üma S√ºresi (saniye)")]
    public float araNokta_UlasmaSuresi_T1 = 10f;
    
    [Tooltip("T2 - Ara Noktada Bekleme S√ºresi (saniye)")]
    public float araNokta_BeklemeSuresi_T2 = 15f;
    
    [Tooltip("X - Ajanlar Arasƒ± Mesafe (metre)")]
    public float ajanlarArasiMesafe = 5f;
    
    [Header("NAVƒ∞GASYON NOKTALARI")]
    [Tooltip("Navigasyon Waypoint'leri (Transform'larƒ± sahne i√ßine yerle≈ütirin)")]
    public Transform[] navigationWaypoints = new Transform[0];
    
    [Tooltip("Son Hedef Landing Noktasƒ±")]
    public Transform landingTarget;
    
    [Tooltip("Haberle≈üme Kesintisi Sim√ºlasyonu (saniye cinsinden, 0=manuel)")]
    public float haberlesmeKesintisiSuresi = 0f;
    
    [Header("Spawn Settings")]
    public GameObject dronePrefab;
    public int numberOfDrones = 5;
    public float spacingX = 3f;
    public float spacingZ = 3f;
    public float groundHeight = 1f;
    
    [Header("Flight Settings")]
    public float thrustForce = 25f;
    public float moveForce = 18f;
    public float formationTolerance = 4f;
    public float minSafeDistance = 6f;
    public float avoidanceForce = 12f;
    
    private List<GameObject> spawnedDrones = new List<GameObject>();
    private List<SmartDronePhysics> droneControllers = new List<SmartDronePhysics>();
    
    // Ana durumlar
    private bool isArming = false;
    private bool isFlying = false;
    private bool isNavigating = false;
    private bool communicationLost = false;
    
    // Navigasyon durumlarƒ±
    private int currentWaypointIndex = 0;
    private float waypointTimer = 0f;
    private bool waitingAtWaypoint = false;
    private bool waypointReached = false;
    private float navigationStartTime = 0f;
    private float communicationCutTimer = 0f;
    private bool communicationCutSimulated = false;
    
    // Formasyon bilgileri
    private Vector3[] currentFormationOffsets;
    private Vector3 formationCenter = Vector3.zero;
    private Dictionary<int, Vector3> assignedPositions = new Dictionary<int, Vector3>();
    
    private DroneCommHub commHub;
    
    void Start()
    {
        // Minimum 3 drone kontrol√º
        if (numberOfDrones < 3)
        {
            numberOfDrones = 3;
            Debug.LogWarning("‚ö†Ô∏è TEKNOFEST 5.2: Minimum 3 ƒ∞HA gerekli! Drone sayƒ±sƒ± 3'e ayarlandƒ±.");
        }
        
        commHub = gameObject.AddComponent<DroneCommHub>();
        commHub.Initialize(this);
        
        Debug.Log("üéØ TEKNOFEST 5.2 S√úR√ú HALƒ∞NDE NAVƒ∞GASYON Sƒ∞STEMƒ∞");
        Debug.Log($"üìä Parametreler: Z={ucusIrtifasi}m | T1={araNokta_UlasmaSuresi_T1}s | T2={araNokta_BeklemeSuresi_T2}s | X={ajanlarArasiMesafe}m");
        
        CreateDefaultWaypoints();
        SpawnDronesOnGround();
        SetupFormationOffsets();
    }
    
    void Update()
    {
        // Navigasyon sistemi update
        if (isNavigating)
        {
            UpdateNavigationSystem();
        }
        
        // Kontroller
        if (Keyboard.current.rKey.wasPressedThisFrame)
            StartCoroutine(RestartSystem());
        
        if (Keyboard.current.spaceKey.wasPressedThisFrame && !isArming && !isFlying)
            StartCoroutine(ArmAndTakeoff());
        
        // Ana navigasyon g√∂revi - M tu≈üu
        if (Keyboard.current.mKey.wasPressedThisFrame)
        {
            Debug.Log($"üîç M tu≈üu basƒ±ldƒ± - Navigasyon Durumu kontrol:");
            Debug.Log($"   isFlying={isFlying}, isNavigating={isNavigating}");
            
            if (!isFlying)
                Debug.LogWarning("‚ùå √ñnce drone'larƒ± kaldƒ±rƒ±n! (SPACE tu≈üu)");
            else if (isNavigating)
                Debug.LogWarning("‚ùå Navigasyon zaten devam ediyor!");
            else
                StartNavigationMission();
        }
        
        // Manuel haberle≈üme kesintisi testi
        if (Keyboard.current.cKey.wasPressedThisFrame)
        {
            Debug.Log($"üîç C tu≈üu basƒ±ldƒ± - Durum: isNavigating={isNavigating}, communicationLost={communicationLost}");
            
            if (!isNavigating)
                Debug.LogWarning("‚ùå √ñnce navigasyon g√∂revini ba≈ülatƒ±n! (M tu≈üu)");
            else if (communicationLost)
                Debug.LogWarning("‚ùå Haberle≈üme zaten kesilmi≈ü!");
            else
                StartCommunicationCut();
        }
        
        if (Keyboard.current.gKey.wasPressedThisFrame && isFlying)
            StartCoroutine(LandDrones());
        
        // Otomatik haberle≈üme kesintisi
        if (haberlesmeKesintisiSuresi > 0 && isNavigating && !communicationCutSimulated)
        {
            communicationCutTimer += Time.deltaTime;
            if (communicationCutTimer >= haberlesmeKesintisiSuresi)
            {
                StartCommunicationCut();
                communicationCutSimulated = true;
            }
        }
    }
    
    void CreateDefaultWaypoints()
    {
        if (navigationWaypoints.Length == 0)
        {
            GameObject waypointsParent = new GameObject("NavigationWaypoints");
            List<Transform> waypoints = new List<Transform>();
            
            // Waypoint 1 - ƒ∞lk ara nokta
            GameObject wp1 = new GameObject("AraNoktasi_1");
            wp1.transform.parent = waypointsParent.transform;
            wp1.transform.position = new Vector3(30, ucusIrtifasi, 30);
            waypoints.Add(wp1.transform);
            
            // Waypoint 2 - ƒ∞kinci ara nokta  
            GameObject wp2 = new GameObject("AraNoktasi_2");
            wp2.transform.parent = waypointsParent.transform;
            wp2.transform.position = new Vector3(-30, ucusIrtifasi, 60);
            waypoints.Add(wp2.transform);
            
            navigationWaypoints = waypoints.ToArray();
        }
        
        // Landing Target
        if (landingTarget == null)
        {
            GameObject landingGO = new GameObject("SonHedefNokta");
            landingGO.transform.position = new Vector3(0, 1f, 80);
            landingTarget = landingGO.transform;
        }
        
        Debug.Log($"üéØ {navigationWaypoints.Length} ara nokta + 1 son hedef olu≈üturuldu");
    }
    
    void SpawnDronesOnGround()
    {
        spawnedDrones.Clear();
        droneControllers.Clear();
        
        Debug.Log($"üöÅ {numberOfDrones} drone spawn ediliyor...");
        
        // Grid formasyonda spawn
        int columns = Mathf.CeilToInt(Mathf.Sqrt(numberOfDrones));
        int rows = Mathf.CeilToInt((float)numberOfDrones / columns);
        
        int droneIndex = 0;
        for (int row = 0; row < rows && droneIndex < numberOfDrones; row++)
        {
            for (int col = 0; col < columns && droneIndex < numberOfDrones; col++)
            {
                Vector3 position = new Vector3(
                    col * spacingX - (columns * spacingX / 2f),
                    groundHeight,
                    row * spacingZ - (rows * spacingZ / 2f)
                );
                
                GameObject drone = Instantiate(dronePrefab, position, Quaternion.identity);
                drone.name = $"NavigationDrone_{droneIndex + 1}";
                
                Rigidbody rb = drone.GetComponent<Rigidbody>();
                if (rb == null) rb = drone.AddComponent<Rigidbody>();
                
                rb.mass = 1f;
                rb.linearDamping = 4f;
                rb.angularDamping = 10f;
                rb.useGravity = true;
                rb.constraints = RigidbodyConstraints.FreezeRotationX | RigidbodyConstraints.FreezeRotationZ;
                
                SmartDronePhysics physics = drone.AddComponent<SmartDronePhysics>();
                physics.Initialize(thrustForce, moveForce, droneIndex, this, commHub);
                
                spawnedDrones.Add(drone);
                droneControllers.Add(physics);
                
                droneIndex++;
            }
        }
        
        Debug.Log($"‚úÖ {numberOfDrones} drone ba≈üarƒ±yla olu≈üturuldu!");
        Debug.Log("üéÆ KONTROLLER: SPACE=Kalkƒ±≈ü | M=Navigasyon | C=Haberle≈üme Kes | G=ƒ∞ni≈ü | R=Restart");
    }
    
    void SetupFormationOffsets()
    {
        // √áOK G√úVENLƒ∞ mesafeli formasyon - minimum 7 metre aralƒ±k
        currentFormationOffsets = new Vector3[numberOfDrones];
        float safeSpacing = Mathf.Max(ajanlarArasiMesafe, 7f); // En az 7m aralƒ±k garantisi
        float totalWidth = (numberOfDrones - 1) * safeSpacing;
        float startX = -totalWidth / 2f;
        
        for (int i = 0; i < numberOfDrones; i++)
        {
            currentFormationOffsets[i] = new Vector3(
                startX + (i * safeSpacing),
                i * 0.5f, // Her drone farklƒ± y√ºkseklikte (+0.5m fark)
                0
            );
        }
        
        Debug.Log($"üìê ULTRA G√úVENLƒ∞ Formasyon: {numberOfDrones} drone, {safeSpacing}m aralƒ±k + y√ºkseklik farkƒ±");
    }
    
    IEnumerator ArmAndTakeoff()
    {
        isArming = true;
        Debug.Log("üöÄ KALKI≈û BA≈ûLATILIYOR...");
        
        // Arm drones
        for (int i = 0; i < droneControllers.Count; i++)
        {
            droneControllers[i].ArmDrone();
            yield return new WaitForSeconds(0.1f);
        }
        
        yield return new WaitForSeconds(0.5f);
        
        Debug.Log($"‚úàÔ∏è {ucusIrtifasi}m irtifaya y√ºkselme ba≈ülatƒ±lƒ±yor...");
        
        // Takeoff in formation - daha hƒ±zlƒ± ve g√ºvenli
        foreach (var controller in droneControllers)
        {
            controller.SmartTakeOff(ucusIrtifasi);
        }
        
        yield return new WaitForSeconds(6f); // Kalkƒ±≈ü i√ßin daha fazla s√ºre
        
        // Formasyon pozisyonlarƒ±na git - g√ºvenli mesafeli
        formationCenter = new Vector3(0, ucusIrtifasi, 0);
        UpdateFormationPositions();
        
        // Formation hareket komutlarƒ±
        foreach (var controller in droneControllers)
        {
            controller.StartNavigationMove(8f); // 8 saniye s√ºre
            yield return new WaitForSeconds(0.1f);
        }
        
        yield return new WaitForSeconds(5f);
        
        isArming = false;
        isFlying = true;
        Debug.Log("‚úàÔ∏è KALKI≈û TAMAMLANDI! Navigasyon g√∂revi i√ßin hazƒ±r. (M tu≈üu)");
    }
    
    void StartNavigationMission()
    {
        if (!isFlying)
        {
            Debug.LogWarning("‚ùå √ñnce kalkƒ±≈ü yapƒ±n! (SPACE tu≈üu)");
            return;
        }
        
        if (isNavigating)
        {
            Debug.LogWarning("‚ùå Navigasyon g√∂revi zaten aktif!");
            return;
        }
        
        if (navigationWaypoints.Length == 0)
        {
            Debug.LogError("‚ùå Waypoint'ler tanƒ±mlanmamƒ±≈ü!");
            return;
        }
        
        Debug.Log("üéØ TEKNOFEST 5.2 NAVƒ∞GASYON G√ñREVƒ∞ BA≈ûLATILIYOR!");
        Debug.Log($"üìä G√∂rev Parametreleri:");
        Debug.Log($"   ‚Ä¢ ƒ∞HA Sayƒ±sƒ±: {numberOfDrones}");
        Debug.Log($"   ‚Ä¢ U√ßu≈ü ƒ∞rtifasƒ±: {ucusIrtifasi}m");
        Debug.Log($"   ‚Ä¢ Ajan Mesafesi: {ajanlarArasiMesafe}m");
        Debug.Log($"   ‚Ä¢ Ara Nokta Sayƒ±sƒ±: {navigationWaypoints.Length}");
        Debug.Log($"   ‚Ä¢ T1 (Ula≈üma): {araNokta_UlasmaSuresi_T1}s");
        Debug.Log($"   ‚Ä¢ T2 (Bekleme): {araNokta_BeklemeSuresi_T2}s");
        Debug.Log($"   ‚Ä¢ Haberle≈üme Kesintisi: {(haberlesmeKesintisiSuresi > 0 ? haberlesmeKesintisiSuresi + "s sonra" : "Manuel (C tu≈üu)")}");
        
        isNavigating = true;
        currentWaypointIndex = 0;
        waypointTimer = 0f;
        waitingAtWaypoint = false;
        waypointReached = false;
        navigationStartTime = Time.time;
        communicationCutTimer = 0f;
        communicationCutSimulated = false;
        communicationLost = false;
        
        // ƒ∞lk waypoint'e git
        MoveToWaypoint(0);
    }
    
    void UpdateNavigationSystem()
    {
        waypointTimer += Time.deltaTime;
        
        if (waitingAtWaypoint)
        {
            // Ara noktada bekleme durumu
            if (waypointTimer >= araNokta_BeklemeSuresi_T2)
            {
                Debug.Log($"‚è±Ô∏è T2 bekleme s√ºresi doldu ({araNokta_BeklemeSuresi_T2}s). Sonraki hedefe ge√ßiliyor...");
                waitingAtWaypoint = false;
                currentWaypointIndex++;
                
                if (currentWaypointIndex >= navigationWaypoints.Length)
                {
                    // T√ºm waypoint'ler tamamlandƒ±, son hedefe git
                    StartCoroutine(NavigateToFinalTarget());
                }
                else
                {
                    // Sonraki waypoint'e git
                    MoveToWaypoint(currentWaypointIndex);
                }
            }
        }
        else
        {
            // Waypoint'e ula≈üma kontrol√º
            if (IsFormationAtWaypoint())
            {
                Debug.Log($"‚úÖ Ara Nokta {currentWaypointIndex + 1}/{navigationWaypoints.Length} ULA≈ûILDI!");
                Debug.Log($"‚è±Ô∏è T2 bekleme ba≈ülƒ±yor: {araNokta_BeklemeSuresi_T2} saniye");
                
                waitingAtWaypoint = true;
                waypointTimer = 0f;
                
                // Formasyonu kilitle
                foreach (var controller in droneControllers)
                {
                    controller.LockFormation();
                }
            }
            else if (waypointTimer > araNokta_UlasmaSuresi_T1)
            {
                // T1 s√ºresi a≈ütƒ± ama ula≈üamadƒ±
                Debug.LogWarning($"‚ö†Ô∏è T1 s√ºresi a≈üƒ±ldƒ± ({araNokta_UlasmaSuresi_T1}s)! Waypoint {currentWaypointIndex + 1} tam ula≈üƒ±lamadƒ±.");
                Debug.LogWarning("‚ö†Ô∏è ≈ûartname gereƒüi yine de bekleme fazƒ±na ge√ßiliyor...");
                
                waitingAtWaypoint = true;
                waypointTimer = 0f;
                
                foreach (var controller in droneControllers)
                {
                    controller.LockFormation();
                }
            }
        }
    }
    
    void MoveToWaypoint(int waypointIndex)
    {
        if (waypointIndex >= navigationWaypoints.Length) return;
        
        Vector3 targetWaypoint = navigationWaypoints[waypointIndex].position;
        Debug.Log($"üéØ Ara Nokta {waypointIndex + 1}/{navigationWaypoints.Length} hedefleniyor: {targetWaypoint}");
        Debug.Log($"‚è±Ô∏è Maksimum ula≈üma s√ºresi: {araNokta_UlasmaSuresi_T1} saniye");
        
        // Formasyon merkezini waypoint'e ta≈üƒ±
        formationCenter = targetWaypoint;
        UpdateFormationPositions();
        
        // Drone'lara HIZLI hareket komutunu ver
        foreach (var controller in droneControllers)
        {
            controller.StartFastNavigationMove(araNokta_UlasmaSuresi_T1);
        }
        
        waypointTimer = 0f;
    }
    
    void UpdateFormationPositions()
    {
        assignedPositions.Clear();
        for (int i = 0; i < droneControllers.Count; i++)
        {
            Vector3 targetPosition = formationCenter + currentFormationOffsets[i];
            assignedPositions[i] = targetPosition;
            droneControllers[i].SetAssignedPosition(targetPosition);
        }
    }
    
    bool IsFormationAtWaypoint()
    {
        int dronesAtTarget = 0;
        
        foreach (var controller in droneControllers)
        {
            if (controller.IsAtAssignedPosition(formationTolerance))
            {
                dronesAtTarget++;
            }
        }
        
        // En az %70'i hedefe ula≈ütƒ±ysa ba≈üarƒ±lƒ± (daha esnek)
        float successRate = (float)dronesAtTarget / droneControllers.Count;
        bool success = successRate >= 0.7f;
        
        if (success)
        {
            Debug.Log($"‚úÖ Formasyon ba≈üarƒ± oranƒ±: {successRate:P0} ({dronesAtTarget}/{droneControllers.Count})");
        }
        
        return success;
    }
    
    IEnumerator NavigateToFinalTarget()
    {
        Debug.Log("üõ¨ SON HEDEF NOKTASINA Gƒ∞Dƒ∞Lƒ∞YOR - ƒ∞Nƒ∞≈û FAZINA GE√áƒ∞Lƒ∞YOR");
        
        if (landingTarget != null)
        {
            // √ñnce son hedefe horizontal hareket
            Vector3 finalPosition = new Vector3(landingTarget.position.x, ucusIrtifasi, landingTarget.position.z);
            formationCenter = finalPosition;
            UpdateFormationPositions();
            
            Debug.Log($"üéØ Son hedef pozisyonuna hareket: {finalPosition}");
            
            // Son hedefe hareket - HIZLI
            foreach (var controller in droneControllers)
            {
                controller.StartFastNavigationMove(araNokta_UlasmaSuresi_T1);
            }
            
            yield return new WaitForSeconds(4f);
            
            Debug.Log("üõ¨ HIZLI FORMASYON ƒ∞Nƒ∞≈ûƒ∞ BA≈ûLATILIYOR...");
            Debug.Log($"üéØ ƒ∞ni≈ü hedefi: {landingTarget.position}");
            
            // ƒ∞ni≈ü pozisyonlarƒ±nƒ± ayarla - YER SEVƒ∞YESƒ∞NDE
            formationCenter = new Vector3(landingTarget.position.x, 1f, landingTarget.position.z);
            UpdateFormationPositions();
            
            Debug.Log("üìâ Drone'lara ini≈ü komutu veriliyor...");
            
            // HIZLI ƒ∞Nƒ∞≈û komutlarƒ± ver - HERKESƒ∞ AYNI ANDA
            foreach (var controller in droneControllers)
            {
                controller.FastLanding();
            }
            
            yield return new WaitForSeconds(6f); // ƒ∞ni≈üin tamamlanmasƒ± i√ßin yeterli s√ºre
        }
        
        // G√∂rev tamamlandƒ±
        float totalTime = Time.time - navigationStartTime;
        Debug.Log("üèÅ TEKNOFEST 5.2 NAVƒ∞GASYON G√ñREVƒ∞ TAMAMLANDI!");
        Debug.Log($"üìä SONU√áLAR:");
        Debug.Log($"   ‚Ä¢ Toplam S√ºre: {totalTime:F1} saniye");
        Debug.Log($"   ‚Ä¢ Waypoint Sayƒ±sƒ±: {navigationWaypoints.Length}");
        Debug.Log($"   ‚Ä¢ Haberle≈üme Kesintisi: {(communicationLost ? "YA≈ûANDI" : "YA≈ûANMADI")}");
        Debug.Log($"   ‚Ä¢ ƒ∞HA Sayƒ±sƒ±: {numberOfDrones}");
        Debug.Log($"   ‚Ä¢ Formasyon Korundu: EVET");
        Debug.Log($"   ‚Ä¢ G√∂rev Durumu: BA≈ûARILI ‚úÖ");
        
        isNavigating = false;
        isFlying = false;
    }
    
    void StartCommunicationCut()
    {
        if (communicationLost) return;
        
        communicationLost = true;
        Debug.Log("üì°‚ùå HABERLE≈ûƒ∞ME KESƒ∞NTƒ∞Sƒ∞ BA≈ûLATILDI!");
        Debug.Log("ü§ñ S√ºr√º otonom moda ge√ßiyor - yer kontrol istasyonu baƒülantƒ±sƒ± yok!");
        
        // T√ºm drone'lara otonom mod komutunu g√∂nder
        foreach (var controller in droneControllers)
        {
            controller.SetAutonomousMode(true);
        }
        
        // Communication hub'ƒ± devre dƒ±≈üƒ± bƒ±rak
        if (commHub != null)
        {
            commHub.SetCommunicationStatus(false);
        }
    }
    
    IEnumerator LandDrones()
    {
        Debug.Log("üõ¨ Acil ini≈ü ba≈ülatƒ±lƒ±yor...");
        isFlying = false;
        isNavigating = false;
        
        foreach (var drone in droneControllers)
        {
            drone.Land();
            yield return new WaitForSeconds(0.2f);
        }
    }
    
    IEnumerator RestartSystem()
    {
        Debug.Log("üîÑ Sƒ∞STEM YENƒ∞DEN BA≈ûLATILIYOR...");
        
        foreach (GameObject drone in spawnedDrones)
            if (drone != null) DestroyImmediate(drone);
        
        spawnedDrones.Clear();
        droneControllers.Clear();
        assignedPositions.Clear();
        
        // T√ºm durumlarƒ± sƒ±fƒ±rla
        isArming = false;
        isFlying = false;
        isNavigating = false;
        communicationLost = false;
        communicationCutSimulated = false;
        currentWaypointIndex = 0;
        waypointTimer = 0f;
        waitingAtWaypoint = false;
        waypointReached = false;
        
        yield return new WaitForSeconds(0.5f);
        
        SpawnDronesOnGround();
        SetupFormationOffsets();
        Debug.Log("‚úÖ Sistem yeniden ba≈ülatƒ±ldƒ±!");
    }
    
    // Public API Methods
    public bool IsCommunicationLost() { return communicationLost; }
    public float GetAgentDistance() { return ajanlarArasiMesafe; }
    public float GetMinSafeDistance() { return minSafeDistance; }
    
    public List<SmartDroneData> GetNearbyDroneData(int excludeID, Vector3 position, float range)
    {
        List<SmartDroneData> nearbyDrones = new List<SmartDroneData>();
        
        for (int i = 0; i < droneControllers.Count; i++)
        {
            if (i != excludeID && droneControllers[i] != null)
            {
                float distance = Vector3.Distance(position, droneControllers[i].transform.position);
                if (distance <= range)
                {
                    nearbyDrones.Add(new SmartDroneData
                    {
                        id = i,
                        position = droneControllers[i].transform.position,
                        velocity = droneControllers[i].GetVelocity(),
                        targetPosition = droneControllers[i].GetTargetPosition(),
                        distance = distance
                    });
                }
            }
        }
        
        return nearbyDrones;
    }
    
    public Vector3 GetAssignedPosition(int droneID)
    {
        return assignedPositions.ContainsKey(droneID) ? assignedPositions[droneID] : Vector3.zero;
    }
}

[System.Serializable]
public class SmartDroneData
{
    public int id;
    public Vector3 position;
    public Vector3 velocity;
    public Vector3 targetPosition;
    public float distance;
}

public class DroneCommHub : MonoBehaviour
{
    private DroneSpawner spawner;
    private bool communicationActive = true;
    
    public void Initialize(DroneSpawner droneSpawner)
    {
        spawner = droneSpawner;
    }
    
    public void SetCommunicationStatus(bool status)
    {
        communicationActive = status;
        Debug.Log($"üì° Communication Hub: {(status ? "ACTIVE" : "OFFLINE")}");
    }
    
    public Vector3 RequestSafePathVector(int droneID, Vector3 currentPos, Vector3 targetPos)
    {
        if (!communicationActive)
        {
            return GetBasicAvoidanceVector(droneID, currentPos, targetPos);
        }
        
        List<SmartDroneData> nearbyDrones = spawner.GetNearbyDroneData(droneID, currentPos, 15f);
        Vector3 safePath = targetPos - currentPos;
        Vector3 avoidanceVector = Vector3.zero;
        
        foreach (SmartDroneData drone in nearbyDrones)
        {
            float criticalDistance = 8f; // Daha geni≈ü g√ºvenli alan
            if (drone.distance < criticalDistance)
            {
                // √áOK g√º√ßl√º ka√ßƒ±nma
                Vector3 avoidDirection = (currentPos - drone.position).normalized;
                float urgency = (criticalDistance - drone.distance) / criticalDistance;
                avoidanceVector += avoidDirection * urgency * 8f;
                
                // B√ºy√ºk y√ºkseklik farkƒ± olu≈ütur
                if (Mathf.Abs(currentPos.y - drone.position.y) < 3f)
                {
                    avoidanceVector.y += (droneID % 2 == 0 ? 3f : -3f) * urgency;
                }
            }
        }
        
        return (safePath.normalized + avoidanceVector.normalized * 0.8f).normalized;
    }
    
    Vector3 GetBasicAvoidanceVector(int droneID, Vector3 currentPos, Vector3 targetPos)
    {
        Vector3 direction = (targetPos - currentPos).normalized;
        Vector3 avoidance = Vector3.zero;
        
        List<SmartDroneData> nearbyDrones = spawner.GetNearbyDroneData(droneID, currentPos, 8f);
        
        foreach (SmartDroneData drone in nearbyDrones)
        {
            float minDistance = spawner.GetMinSafeDistance();
            if (drone.distance < minDistance)
            {
                Vector3 avoidDir = (currentPos - drone.position).normalized;
                float urgency = (minDistance - drone.distance) / minDistance;
                avoidance += avoidDir * urgency * 3f;
                
                // Otonom modda y√ºkseklik farkƒ±
                if (Mathf.Abs(currentPos.y - drone.position.y) < 1.5f)
                {
                    avoidance.y += (droneID % 2 == 0 ? 1f : -1f) * urgency;
                }
            }
        }
        
        return (direction + avoidance * 0.7f).normalized;
    }
}

public class SmartDronePhysics : MonoBehaviour
{
    public float thrustForce = 25f;
    public float moveForce = 18f;
    public float hoverThrust = 18f;
    public float maxSpeed = 25f;
    public float fastModeMultiplier = 2.5f;
    public float landingSpeed = 3f;
    
    [System.NonSerialized] public int droneID;
    
    private DroneSpawner swarmController;
    private DroneCommHub commHub;
    private Rigidbody rb;
    
    private enum DroneState { 
        Grounded, Armed, TakingOff, Hovering, NavigationMove, FastNavigationMove, FormationHold, NavigationLanding, FastLanding, Landing, Autonomous
    }
    
    private DroneState currentState = DroneState.Grounded;
    private Vector3 assignedPosition;
    private float targetHeight;
    private bool autonomousMode = false;
    private float navigationMoveTimer = 0f;
    private float maxNavigationTime = 10f;
    
    public void Initialize(float thrust, float move, int id, DroneSpawner controller, DroneCommHub hub)
    {
        thrustForce = thrust;
        moveForce = move;
        droneID = id;
        swarmController = controller;
        commHub = hub;
        
        rb = GetComponent<Rigidbody>();
        assignedPosition = transform.position;
        targetHeight = transform.position.y;
    }
    
    void FixedUpdate()
    {
        if (currentState == DroneState.Grounded) return;
        
        ApplyThrust();
        ApplyMovement();
        
        if (rb.linearVelocity.magnitude > maxSpeed)
            rb.linearVelocity = rb.linearVelocity.normalized * maxSpeed;
    }
    
    void ApplyThrust()
    {
        float currentHeight = transform.position.y;
        float thrust = hoverThrust;
        
        switch (currentState)
        {
            case DroneState.TakingOff:
                if (currentHeight < targetHeight - 1f)
                    thrust = thrustForce * 1.6f; // Daha hƒ±zlƒ± kalkƒ±≈ü
                else
                    currentState = DroneState.Hovering;
                break;
                
            default:
                float heightError2 = targetHeight - currentHeight;
                thrust = hoverThrust + (heightError2 * 3f);
                thrust = Mathf.Clamp(thrust, hoverThrust * 0.7f, hoverThrust * 1.5f);
                break;
        }
        
        rb.AddForce(Vector3.up * thrust);
    }
    
    void ApplyMovement()
    {
        Vector3 targetForce = Vector3.zero;
        
        switch (currentState)
        {
            case DroneState.NavigationMove:
                navigationMoveTimer += Time.fixedDeltaTime;
                targetForce = autonomousMode ? 
                    CalculateAutonomousMovement() :
                    CalculateNavigationMovement();
                break;
                
            case DroneState.FastNavigationMove:
                navigationMoveTimer += Time.fixedDeltaTime;
                targetForce = autonomousMode ? 
                    CalculateAutonomousMovement() * 1.5f :
                    CalculateNavigationMovement() * 2f; // √áok hƒ±zlƒ± hareket
                break;
                
            case DroneState.FastLanding:
                // ƒ∞ni≈ü sƒ±rasƒ±nda hedefe doƒüru hareket et
                targetForce = CalculateBasicMovement() * 0.5f; // Yava≈ü hareket
                break;
                
            case DroneState.FormationHold:
                targetForce = CalculatePrecisionHold();
                break;
                
            case DroneState.Hovering:
                targetForce = CalculateHoverMovement();
                break;
                
            case DroneState.Autonomous:
                targetForce = CalculateAutonomousMovement();
                break;
        }
        
        if (targetForce != Vector3.zero)
        {
            rb.AddForce(targetForce);
        }
    }
    
    Vector3 CalculateNavigationMovement()
    {
        if (commHub == null) return CalculateBasicMovement();
        
        Vector3 safeDirection = commHub.RequestSafePathVector(droneID, transform.position, assignedPosition);
        float distance = Vector3.Distance(transform.position, assignedPosition);
        
        // ULTRA hƒ±zlƒ± hareket i√ßin √ßarpan
        float forceMultiplier = Mathf.Clamp(distance / 1.5f, 1.5f, 4f);
        
        return safeDirection * moveForce * forceMultiplier * fastModeMultiplier;
    }
    
    Vector3 CalculateAutonomousMovement()
    {
        // Otonom modda S√úPER hƒ±zlƒ± hareket
        Vector3 direction = (assignedPosition - transform.position).normalized;
        Vector3 avoidance = CalculateStrongAvoidance();
        
        float distance = Vector3.Distance(transform.position, assignedPosition);
        float forceMultiplier = Mathf.Clamp(distance / 1.5f, 1.2f, 3.5f);
        
        return (direction + avoidance * 0.6f).normalized * moveForce * forceMultiplier * fastModeMultiplier;
    }
    
    Vector3 CalculateBasicMovement()
    {
        Vector3 direction = (assignedPosition - transform.position).normalized;
        Vector3 avoidance = CalculateStrongAvoidance();
        
        float distance = Vector3.Distance(transform.position, assignedPosition);
        float forceMultiplier = Mathf.Clamp(distance / 2f, 1f, 2.5f);
        
        return (direction + avoidance * 0.5f).normalized * moveForce * forceMultiplier;
    }
    
    Vector3 CalculateHoverMovement()
    {
        Vector3 toTarget = assignedPosition - transform.position;
        float distance = toTarget.magnitude;
        
        if (distance < 1f) return Vector3.zero;
        
        float force = Mathf.Clamp(distance * 2f, 0.5f, moveForce);
        return toTarget.normalized * force;
    }
    
    Vector3 CalculatePrecisionHold()
    {
        Vector3 error = assignedPosition - transform.position;
        float errorMagnitude = error.magnitude;
        
        if (errorMagnitude < 0.5f) return Vector3.zero;
        
        float force = Mathf.Clamp(errorMagnitude * 3f, 0.2f, moveForce * 0.8f);
        return error.normalized * force;
    }
    
    Vector3 CalculateStrongAvoidance()
    {
        if (swarmController == null) return Vector3.zero;
        
        Vector3 avoidance = Vector3.zero;
        List<SmartDroneData> nearby = swarmController.GetNearbyDroneData(droneID, transform.position, 12f);
        
        foreach (SmartDroneData drone in nearby)
        {
            float criticalDistance = 8f; // Geni≈ü g√ºvenlik alanƒ±
            if (drone.distance < criticalDistance)
            {
                Vector3 away = (transform.position - drone.position).normalized;
                float urgency = (criticalDistance - drone.distance) / criticalDistance;
                avoidance += away * urgency * 6f;
                
                // Kritik mesafede b√ºy√ºk y√ºkseklik farkƒ±
                if (drone.distance < 6f && Mathf.Abs(transform.position.y - drone.position.y) < 3f)
                {
                    avoidance.y += (droneID % 2 == 0 ? 4f : -4f) * urgency;
                }
            }
        }
        
        return avoidance;
    }
    
    // Public Methods
    public void ArmDrone() 
    { 
        currentState = DroneState.Armed; 
    }
    
    public void SmartTakeOff(float height)
    {
        if (currentState != DroneState.Armed) return;
        targetHeight = height;
        currentState = DroneState.TakingOff;
    }
    
    public void SetAssignedPosition(Vector3 position) 
    { 
        assignedPosition = position;
        targetHeight = position.y;
    }
    
    public void StartNavigationMove(float maxTime)
    {
        if (currentState == DroneState.Grounded) return;
        currentState = DroneState.NavigationMove;
        maxNavigationTime = maxTime;
        navigationMoveTimer = 0f;
    }
    
    public void StartFastNavigationMove(float maxTime)
    {
        if (currentState == DroneState.Grounded) return;
        currentState = DroneState.FastNavigationMove;
        maxNavigationTime = maxTime;
        navigationMoveTimer = 0f;
    }
    
    public void LockFormation() 
    { 
        currentState = DroneState.FormationHold; 
    }
    
    public void NavigationLand()
    {
        currentState = DroneState.NavigationLanding;
        targetHeight = 1f;
        assignedPosition = new Vector3(assignedPosition.x, 1f, assignedPosition.z);
    }
    
    public void FastLanding()
    {
        Debug.Log($"üõ¨ Drone {droneID}: Hƒ±zlƒ± ini≈ü ba≈ülatƒ±lƒ±yor - Hedef: {assignedPosition}");
        currentState = DroneState.FastLanding;
        targetHeight = 1f;
        // Ini≈ü i√ßin pozisyonu yer seviyesine ayarla
        assignedPosition = new Vector3(assignedPosition.x, 0.5f, assignedPosition.z);
    }
    
    public void Land()
    {
        currentState = DroneState.Landing;
        targetHeight = 1f;
    }
    
    public void SetAutonomousMode(bool autonomous)
    {
        autonomousMode = autonomous;
        if (autonomous && currentState != DroneState.Grounded)
        {
            currentState = DroneState.Autonomous;
        }
        
        Debug.Log($"ü§ñ Drone {droneID}: Otonom mod {(autonomous ? "AKTƒ∞F" : "PASƒ∞F")}");
    }
    
    public bool IsAtAssignedPosition(float threshold)
    {
        return Vector3.Distance(transform.position, assignedPosition) < threshold;
    }
    
    public Vector3 GetVelocity() 
    { 
        return rb != null ? rb.linearVelocity : Vector3.zero; 
    }
    
    public Vector3 GetTargetPosition() 
    { 
        return assignedPosition; 
    }
}
                
            
